            startp = len(Mbr().doSerialize())
            indexp = 0
            particiones = []
            diferencias = []
            particionf = None
            
            #Se recorren las particiones
            
            for partition in crr_mbr.mbr_partition:                
                #Se evalua si la particion no esta ocupada y el tamaÃ±o es valido
                if(partition.part_status == b'\x00' and partition.part_size >= self.size):                    
                    #Se agrega la particion
                    particiones.append(partition)                    
                    #Se evalua la diferencia
                    diferencia = partition.part_size - self.size
                    diferencias.append(diferencia)      
            
            #Segun el fit, se observan las particiones validas
            if(self.fit == 'B'):
                menor_dif = min(diferencias)
                index = diferencias.index(menor_dif)
                particionf = particiones[index]
            elif(self.fit == 'F'):
                particionf = particiones[0]
            elif(self.fit == 'W'):
                mayor_dif = max(diferencias)
                index = diferencias.index(mayor_dif)
                particionf = particiones[index]
                
            #Se recorren otra vez las particiones para encontrar el index y el comienzo de la escritura
            for partition in crr_mbr.mbr_partition:
                if partition.part_name == particionf.part_name:
                    break
                startp += partition.part_size
                indexp += 1
            
            
            pass